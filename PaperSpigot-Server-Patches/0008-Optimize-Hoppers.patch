From 31e0f7fd18c03b247fed725dae8ad4a42cad352b Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 27 Apr 2016 22:09:52 -0400
Subject: [PATCH] Optimize Hoppers

* Removes unnecessary extra calls to .update() that are very expensive
* Lots of itemstack cloning removed. Only clone if the item is actually moved
* Return true when a plugin cancels inventory move item event instead of false, as false causes pulls to cycle through all items.
  However, pushes do not exhibit the same behavior, so this is not something plugins could of been relying on.
* Add option (Default on) to cooldown hoppers when they fail to move an item due to full inventory
* Skip subsequent InventoryMoveItemEvents if a plugin does not use the item after first event fire for an iteration

diff --git a/src/main/java/net/minecraft/server/EntityMinecartHopper.java b/src/main/java/net/minecraft/server/EntityMinecartHopper.java
index eefbdc62d..9c088d83d 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartHopper.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartHopper.java
@@ -5,7 +5,7 @@ import java.util.List;
 public class EntityMinecartHopper extends EntityMinecartContainer implements IHopper {
 
     private boolean a = true;
-    private int b = -1;
+    private int b = -1; public void setCooldown(int cooldown) { this.b = cooldown;} public int getCooldown() { return this.b; } // Alphheim
     private BlockPosition c;
 
     public EntityMinecartHopper(World world) {
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index 015ce2834..817df5732 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -760,4 +760,18 @@ public final class ItemStack {
             return false;
         }
     }
+
+    // Alphheim start - add isEmpty
+    public boolean isEmpty() {
+        return item == null || count <= 0 || (this.damage < -32768 || this.damage > '\uffff');
+    }
+
+    public int getCount() {
+        return count;
+    }
+
+    public void setCount(int count) {
+        this.count = count;
+    }
+    // Alphheim
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 180ba00d2..7a5aacaa2 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -811,6 +811,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
             // if (i == 0 || this.getAllowNether()) {
                 WorldServer worldserver = this.worlds.get(i);
+            TileEntityHopper.skipHopperEvents = worldserver.paperSpigotConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Alphheim
 
                 this.methodProfiler.a(worldserver.getWorldData().getName());
                 /* Drop global time updates
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index f68b132fb..0f89a410f 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -37,6 +37,7 @@ public abstract class TileEntity {
         }
     }
 
+    static boolean IGNORE_TILE_UPDATES = false; // Alphheim
     public World getWorld() {
         return this.world;
     }
@@ -101,6 +102,7 @@ public abstract class TileEntity {
 
     public void update() {
         if (this.world != null) {
+            if (IGNORE_TILE_UPDATES) return;
             IBlockData iblockdata = this.world.getType(this.position);
 
             this.h = iblockdata.getBlock().toLegacyData(iblockdata);
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 760a0767e..6072360d7 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -16,7 +16,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
 
     private ItemStack[] items = new ItemStack[5];
     private String f;
-    private int g = -1;
+    private int g = -1; public void setCooldown(int cooldown) { this.g = cooldown;} public int getCooldown() { return this.g;} // Alphheim - OBFHelper //TODO: MOVE ME
 
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
@@ -240,6 +240,156 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return true;
     }
 
+    // Alphheim start - Paper start - Optimize Hoppers
+    private static boolean skipPullModeEventFire = false;
+    private static boolean skipPushModeEventFire = false;
+    static boolean skipHopperEvents = false;
+
+    private boolean hopperPush(IInventory iinventory, EnumDirection enumdirection) {
+        skipPushModeEventFire = skipHopperEvents;
+        boolean foundItem = false;
+        for (int i = 0; i < this.getSize(); ++i) {
+            if (!this.getItem(i).isEmpty()) {
+                foundItem = true;
+                ItemStack origItemStack = this.getItem(i);
+                ItemStack itemstack = origItemStack;
+
+                final int origCount = origItemStack.getCount();
+                final int moved = Math.min(world.spigotConfig.hopperAmount, origCount);
+                origItemStack.setCount(moved);
+
+                // We only need to fire the event once to give protection plugins a chance to cancel this event
+                // Because nothing uses getItem, every event call should end up the same result.
+                if (!skipPushModeEventFire) {
+                    itemstack = callPushMoveEvent(iinventory, itemstack);
+                    if (itemstack == null) { // cancelled
+                        origItemStack.setCount(origCount);
+                        return false;
+                    }
+                }
+                final ItemStack itemstack2 = addItem(iinventory, itemstack, enumdirection);
+                final int remaining = itemstack2.getCount();
+                if (remaining != moved) {
+                    origItemStack = origItemStack.cloneItemStack();
+                    origItemStack.setCount(origCount - moved + remaining);
+                    this.setItem(i, origItemStack);
+                    iinventory.update();
+                    return true;
+                }
+                origItemStack.setCount(origCount);
+            }
+        }
+        if (foundItem && world.paperSpigotConfig.cooldownHopperWhenFull) { // Inventory was full - cooldown
+            this.setCooldown(world.spigotConfig.hopperTransfer);
+        }
+        return false;
+    }
+
+
+    private static boolean hopperPull(IHopper ihopper, IInventory iinventory, int i) {
+        ItemStack origItemStack = iinventory.getItem(i);
+        ItemStack itemstack = origItemStack;
+        final int origCount = origItemStack.getCount();
+        final World world = ihopper.getWorld();
+        final int moved = Math.min(world.spigotConfig.hopperAmount, origCount);
+        itemstack.setCount(moved);
+
+        if (!skipPullModeEventFire) {
+            itemstack = callPullMoveEvent(ihopper, iinventory, itemstack);
+            if (itemstack == null) { // cancelled
+                origItemStack.setCount(origCount);
+                // Drastically improve performance by returning true.
+                // No plugin could of relied on the behavior of false as the other call
+                // site for IMIE did not exhibit the same behavior
+                return true;
+            }
+        }
+
+        final ItemStack itemstack2 = addItem(ihopper, itemstack, null);
+        final int remaining = itemstack2.getCount();
+        if (remaining != moved) {
+            origItemStack = origItemStack.cloneItemStack();
+            origItemStack.setCount(origCount - moved + remaining);
+            IGNORE_TILE_UPDATES = true;
+            iinventory.setItem(i, origItemStack);
+            IGNORE_TILE_UPDATES = false;
+            iinventory.update();
+            return true;
+        }
+        origItemStack.setCount(origCount);
+
+        if (world.paperSpigotConfig.cooldownHopperWhenFull) {
+            cooldownHopper(ihopper);
+        }
+
+        return false;
+    }
+
+    private ItemStack callPushMoveEvent(IInventory iinventory, ItemStack itemstack) {
+        Inventory destinationInventory = getInventory(iinventory);
+        InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner().getInventory(),
+                CraftItemStack.asCraftMirror(itemstack), destinationInventory, true);
+        boolean result = event.callEvent();
+        if (!event.calledGetItem && !event.calledSetItem) {
+            skipPushModeEventFire = true;
+        }
+        if (!result) {
+            cooldownHopper(this);
+            return null;
+        }
+
+        if (event.calledSetItem) {
+            return CraftItemStack.asNMSCopy(event.getItem());
+        } else {
+            return itemstack;
+        }
+    }
+
+    private static ItemStack callPullMoveEvent(IHopper hopper, IInventory iinventory, ItemStack itemstack) {
+        Inventory sourceInventory = getInventory(iinventory);
+        Inventory destination = getInventory(hopper);
+
+        InventoryMoveItemEvent event = new InventoryMoveItemEvent(sourceInventory,
+                // Mirror is safe as we no plugins ever use this item
+                CraftItemStack.asCraftMirror(itemstack), destination, false);
+        boolean result = event.callEvent();
+        if (!event.calledGetItem && !event.calledSetItem) {
+            skipPullModeEventFire = true;
+        }
+        if (!result) {
+            cooldownHopper(hopper);
+            return null;
+        }
+
+        if (event.calledSetItem) {
+            return CraftItemStack.asNMSCopy(event.getItem());
+        } else {
+            return itemstack;
+        }
+    }
+
+    private static Inventory getInventory(IInventory iinventory) {
+        Inventory sourceInventory;// Have to special case large chests as they work oddly
+        if (iinventory instanceof InventoryLargeChest) {
+            sourceInventory = new org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
+        } else if (iinventory instanceof TileEntity) {
+            sourceInventory = ((TileEntity) iinventory).getOwner().getInventory();
+        } else {
+            sourceInventory = iinventory.getOwner().getInventory();
+        }
+        return sourceInventory;
+    }
+
+    private static void cooldownHopper(IHopper hopper) {
+        if (hopper instanceof TileEntityHopper) {
+            ((TileEntityHopper) hopper).setCooldown(hopper.getWorld().spigotConfig.hopperTransfer);
+        } else if (hopper instanceof EntityMinecartHopper) {
+            ((EntityMinecartHopper) hopper).setCooldown(hopper.getWorld().spigotConfig.hopperTransfer / 2); // TODO: FIX
+        }
+    }
+
+    // Alphheim end - Paper end
+
     private boolean r() {
         IInventory iinventory = this.H();
 
diff --git a/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java b/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java
index 67e56df01..2d82aec7e 100644
--- a/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java
+++ b/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java
@@ -408,4 +408,13 @@ public class PaperSpigotWorldConfig
     {
         disableTeleportationSuffocationCheck = getBoolean("disable-teleportation-suffocation-check", false);
     }
+
+    public boolean cooldownHopperWhenFull = true;
+    public boolean disableHopperMoveEvents = false;
+    private void hopperOptimizations() {
+        cooldownHopperWhenFull = getBoolean("hopper.cooldown-when-full", cooldownHopperWhenFull);
+        log("Cooldown Hoppers when Full: " + (cooldownHopperWhenFull ? "enabled" : "disabled"));
+        disableHopperMoveEvents = getBoolean("hopper.disable-move-event", disableHopperMoveEvents);
+        log("Hopper Move Item Events: " + (disableHopperMoveEvents ? "disabled" : "enabled"));
+    }
 }
-- 
2.16.2

